<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Light Portal Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Light Portal Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>Light Portal is an application that connect the providers to the consumers, and it contains many components or applications. Each component will have some API endpoints and a user interface in the portal view single page application.</p>
<p>To allow the users to understand each component in detail in term of design, we have collected all the design documents in this section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication--authorization"><a class="header" href="#authentication--authorization">Authentication &amp; Authorization</a></h1>
<p>Light-Portal is a single-page application (SPA) that utilizes both the OAuth 2.0 Authorization Code and Client Credentials flows.</p>
<p>The following pattern illustrates the end-to-end process recommended by the Light Platform for an SPA interacting with downstream APIs.</p>
<h3 id="sequence-diagram"><a class="header" href="#sequence-diagram">Sequence Diagram</a></h3>
<pre class="mermaid">sequenceDiagram
    participant PortalView as Portal View
    participant LoginView as Login View
    participant Gateway as Light Gateway
    participant OAuthKafka as OAuth-Kafka
    participant AuthService as Auth Service
    participant ProxySidecar as Proxy Sidecar
    participant BackendAPI as Backend API

    PortalView -&gt;&gt; LoginView: 1. Signin redirect
    LoginView -&gt;&gt; OAuthKafka: 2. Authenticate user
    OAuthKafka -&gt;&gt; AuthService: 3. Authenticate User&lt;br/&gt;(Active Directory&lt;br/&gt;for Employees)&lt;br/&gt;(CIF System&lt;br/&gt;for Customers)
    AuthService -&gt;&gt; OAuthKafka: 4. Authenticated
    OAuthKafka -&gt;&gt; OAuthKafka: 5. Generate auth code
    OAuthKafka -&gt;&gt; PortalView: 6. Redirect with code
    PortalView -&gt;&gt; Gateway: 7. Authorization URL&lt;br/&gt;with code param
    Gateway -&gt;&gt; OAuthKafka: 8. Create JWT access&lt;br/&gt;token with code
    OAuthKafka -&gt;&gt; OAuthKafka: 9. Generate JWT&lt;br/&gt;access token&lt;br/&gt;with user claims
    OAuthKafka -&gt;&gt; Gateway: 10. Token returns&lt;br/&gt;to Gateway
    Gateway -&gt;&gt; PortalView: 11. Token returns&lt;br/&gt;to Portal View&lt;br/&gt;in Secure Cookie
    PortalView -&gt;&gt; Gateway: 12. Call Backend API
    Gateway -&gt;&gt; Gateway: 13. Verify the token
    Gateway -&gt;&gt; OAuthKafka: 14. Create Client&lt;br/&gt;Credentials token
    OAuthKafka -&gt;&gt; OAuthKafka: 15. Generate Token&lt;br/&gt;with Scopes
    OAuthKafka -&gt;&gt; Gateway: 16. Return the&lt;br/&gt;scope token
    Gateway -&gt;&gt; Gateway: 17. Add scope&lt;br/&gt;token to&lt;br/&gt;X-Scope-Token&lt;br/&gt;Header
    Gateway -&gt;&gt; ProxySidecar: 18. Invoke API
    ProxySidecar -&gt;&gt; ProxySidecar: 19. Verify&lt;br/&gt;Authorization&lt;br/&gt;token
    ProxySidecar -&gt;&gt; ProxySidecar: 20. Verify&lt;br/&gt;X-Scope-Token
    ProxySidecar -&gt;&gt; ProxySidecar: 21. Fine-Grained&lt;br/&gt;Authorization
    ProxySidecar -&gt;&gt; BackendAPI: 22. Invoke&lt;br/&gt;business API
    BackendAPI -&gt;&gt; ProxySidecar: 23. Business API&lt;br/&gt;response
    ProxySidecar -&gt;&gt; ProxySidecar: 24. Fine-Grained&lt;br/&gt;response filter
    ProxySidecar -&gt;&gt; Gateway: 25. Return response
    Gateway -&gt;&gt; PortalView: 26. Return response

</pre>
<ol>
<li>
<p>When a user visits the website to access the single-page application (SPA), the Light Gateway serves the SPA to the user's browser. Each single page application will have a dedicated Light Gateway instance acts as a BFF. By default, the user is not logged in and can only access limited site features. To unlock additional features, the user can click the <code>User</code> button in the header and select the <code>Sign In</code> menu. This action redirects the browser from the Portal View to the Login View, both served by the same Light Gateway instance.</p>
</li>
<li>
<p>On the Login View page, the user can either input a username and password or choose Google/Facebook for authentication. When the login form is submitted, the request is sent to the Light Gateway with the user's credentials. The Gateway forwards this request to the OAuth Kafka service.</p>
</li>
<li>
<p>OAuth Kafka supports multiple authenticator implementations to verify user credentials. Examples include authenticating via the Light Portal user database, Active Directory for employees, or CIF service for customers.</p>
</li>
<li>
<p>Once authentication is successfully completed, the OAuth Kafka responds with the authentication result.</p>
</li>
<li>
<p>Upon successful authentication, OAuth Kafka generates an authorization code (a UUID associated with the user's profile).</p>
</li>
<li>
<p>OAuth Kafka redirects the authorization code back to the browser at the Portal View via the Gateway.</p>
</li>
<li>
<p>Since the Portal View SPA lacks a dedicated redirect route for the authorization code, the browser sends the code as a query parameter in a request to the Gateway.</p>
</li>
<li>
<p>The <code>StatelessAuthHandler</code> in the Gateway processes this request, initiating a token request to OAuth Kafka to obtain a JWT access token.</p>
</li>
<li>
<p>OAuth Kafka generates an access token containing user claims in its custom JWT claims. The authorization code is then invalidated, as it is single-use.</p>
</li>
<li>
<p>The access token is returned to the Gateway.</p>
</li>
<li>
<p>The <code>StatelessAuthHandler</code> in the Gateway stores the access token in a secure cookie and sends it back to the Portal View.</p>
</li>
<li>
<p>When the Portal View SPA makes requests to backend APIs, it includes the secure cookie in the API request sent to the Gateway.</p>
</li>
<li>
<p>The <code>StatelessAuthHandler</code> in the Gateway validates the token in the secure cookie and places it in the <code>Authorization</code> header of the outgoing request.</p>
</li>
<li>
<p>If the token is successfully validated, the <code>TokenHandler</code> in the Gateway makes a request to OAuth Kafka for a client credentials token, using the path prefix of the API endpoint.</p>
</li>
<li>
<p>OAuth Kafka generates a client credentials token with the appropriate scope for accessing the downstream service.</p>
</li>
<li>
<p>The client credentials token is returned to the Gateway.</p>
</li>
<li>
<p>The <code>TokenHandler</code> in the Gateway inserts this token into the <code>X-Scope-Token</code> header of the original request.</p>
</li>
<li>
<p>The Gateway routes the original request, now containing both tokens, to the downstream <code>proxy sidecar</code>of the backend API.</p>
</li>
<li>
<p>The proxy sidecar validates the <code>Authorization</code> token, verifying its signature, expiration, and other attributes.</p>
</li>
<li>
<p>The proxy sidecar also validates the <code>X-Scope-Token</code>, ensuring its signature, expiration, and scope are correct.</p>
</li>
<li>
<p>Once both tokens are successfully validated, the proxy sidecar enforces fine-grained authorization rules based on the user's custom security profile contained in the <code>Authorization</code> token.</p>
</li>
<li>
<p>If the fine-grained authorization checks are passed, the proxy sidecar forwards the request to the backend API.</p>
</li>
<li>
<p>The backend API processes the request and sends the full response back to the <code>proxy sidecar</code>.</p>
</li>
<li>
<p>The proxy sidecar applies fine-grained filters to the response, reducing the number of rows and/or columns based on the user's security profile or other policies.</p>
</li>
<li>
<p>The proxy sidecar returns the filtered response to the Gateway.</p>
</li>
<li>
<p>The Gateway forwards the response to the Portal View, allowing the SPA to render the page.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fine-grained-authorization"><a class="header" href="#fine-grained-authorization">Fine-Grained Authorization</a></h1>
<h2 id="what-is-fine-grained-authorization"><a class="header" href="#what-is-fine-grained-authorization">What is Fine-Grained Authorization?</a></h2>
<p>Fine-grained authorization (FGA) refers to a detailed and precise control mechanism that governs access to resources based on specific attributes, roles, or rules. It's also known as fine-grained access control (FGAC). Unlike coarse-grained authorization, which applies broader access policies (e.g., "Admins can access everything"), fine-grained authorization allows for more specific policies (e.g., "Admins can access user data only if they belong to the same department and the access request is during business hours").</p>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<ul>
<li><strong>Granular Control</strong>: Policies are defined at a detailed level, considering attributes like user role, resource type, action, time, location, etc.</li>
<li><strong>Context-Aware</strong>: Takes into account dynamic conditions such as the time of request, user’s location, or other contextual factors.</li>
<li><strong>Flexible Policies</strong>: Allows the creation of complex, conditional rules tailored to the organization’s needs.</li>
</ul>
<h2 id="why-do-we-need-fine-grained-authorization"><a class="header" href="#why-do-we-need-fine-grained-authorization">Why Do We Need Fine-Grained Authorization?</a></h2>
<h3 id="1-enhanced-security"><a class="header" href="#1-enhanced-security">1. <strong>Enhanced Security</strong></a></h3>
<p>By limiting access based on detailed criteria, fine-grained authorization minimizes the risk of unauthorized access or data breaches.</p>
<h3 id="2-regulatory-compliance"><a class="header" href="#2-regulatory-compliance">2. <strong>Regulatory Compliance</strong></a></h3>
<p>It helps organizations comply with legal and industry-specific regulations (e.g., GDPR, HIPAA) by ensuring sensitive data is only accessible under strict conditions.</p>
<h3 id="3-minimized-attack-surface"><a class="header" href="#3-minimized-attack-surface">3. <strong>Minimized Attack Surface</strong></a></h3>
<p>By restricting access to only the required resources and operations, fine-grained authorization reduces the potential impact of insider threats or compromised accounts.</p>
<h3 id="4-improved-user-experience"><a class="header" href="#4-improved-user-experience">4. <strong>Improved User Experience</strong></a></h3>
<p>Enables personalized access based on roles and permissions, ensuring users see only what they need, which reduces confusion and improves productivity.</p>
<h3 id="5-auditing-and-accountability"><a class="header" href="#5-auditing-and-accountability">5. <strong>Auditing and Accountability</strong></a></h3>
<p>Detailed access logs and policy enforcement make it easier to track and audit who accessed what, when, and why, fostering better accountability.</p>
<h2 id="examples-of-use-cases"><a class="header" href="#examples-of-use-cases">Examples of Use Cases</a></h2>
<ul>
<li><strong>Healthcare</strong>: A doctor can only view records of patients they are treating.</li>
<li><strong>Government</strong>: A government employee can access to data and documents based on security clearance levels and job roles.</li>
<li><strong>Finance</strong>: A teller can only access transactions related to their assigned branch.</li>
<li><strong>Enterprise Software</strong>: Employees can edit documents only if they own them or have been granted editing permissions.</li>
</ul>
<h2 id="fine-grained-authorization-in-api-access-control"><a class="header" href="#fine-grained-authorization-in-api-access-control">Fine-Grained Authorization in API Access Control</a></h2>
<p>In API access control, fine-grained authorization governs how users or systems interact with specific API endpoints, actions, and data. This approach ensures that access permissions are precisely tailored to attributes, roles, and contextual factors, enabling a secure and customized API experience. As the Light Portal is a platform centered on APIs, the remainder of the design will focus on the API access control context.</p>
<h2 id="early-approaches-to-fine-grained-authorization"><a class="header" href="#early-approaches-to-fine-grained-authorization">Early Approaches to Fine Grained Authorization</a></h2>
<p>Early approaches to fine grained authorization primarily involved Access Control Lists (ACLs) and Role-Based Access Control (RBAC). These methods laid the foundation for more sophisticated access control mechanisms that followed. Here's an overview of these primary approaches:</p>
<h3 id="access-control-lists-acls"><a class="header" href="#access-control-lists-acls">Access Control Lists (ACLs):</a></h3>
<ul>
<li>
<p>ACLs were one of the earliest forms of fine grained authorization, allowing administrators to specify access permissions on individual resources for each user or group of users.</p>
</li>
<li>
<p>In ACLs, permissions are directly assigned to users or groups, granting or denying access to specific resources based on their identities.</p>
</li>
<li>
<p>While effective for small-scale environments with limited resources and users, ACLs became cumbersome as organizations grew. Maintenance issues arose, such as the time required to manage access to an increasing number of resources for numerous users.</p>
</li>
</ul>
<h3 id="role-based-access-control-rbac"><a class="header" href="#role-based-access-control-rbac">Role-Based Access Control (RBAC):</a></h3>
<ul>
<li>
<p>RBAC emerged as a solution to the scalability and maintenance challenges posed by ACLs. It introduced the concept of roles, which represent sets of permissions associated with particular job functions or responsibilities.</p>
</li>
<li>
<p>Users are assigned one or more roles, and their access permissions are determined by the roles they possess rather than their individual identities.</p>
</li>
<li>
<p>RBAC can be implemented with varying degrees of granularity. Roles can be coarse-grained, providing broad access privileges, or fine-grained, offering more specific and nuanced permissions based on organizational needs.</p>
</li>
<li>
<p>Initially, RBAC appeared to address the limitations of ACLs by providing a more scalable and manageable approach to access control.</p>
</li>
</ul>
<h3 id="both-acls-and-rbac-have-their-shortcomings"><a class="header" href="#both-acls-and-rbac-have-their-shortcomings">Both ACLs and RBAC have their shortcomings:</a></h3>
<ul>
<li>
<p>Maintenance Challenges: While RBAC offered improved scalability compared to ACLs, it still faced challenges with role management as organizations expanded. The proliferation of roles, especially fine grained ones, led to a phenomenon known as <strong>role explosion</strong> where the number of roles grew rapidly, making them difficult to manage effectively.</p>
</li>
<li>
<p>Security Risks: RBAC's flexibility also posed security risks. Over time, users might accumulate permissions beyond what they need for their current roles, leading to a phenomenon known as <strong>permission creep</strong>. This weakened overall security controls and increased the risk of unauthorized access or privilege misuse.</p>
</li>
</ul>
<p>Following the discussion of early approaches to fine grained authorization, it's crucial to acknowledge that different applications have varying needs for authorization.</p>
<p>Whether to use fine grained or coarse-grained controls depends on the specific project. Controlling access becomes trickier due to the spread-out nature of resources and differing levels of detail needed across components. Let’s delve into the differentiating factors:</p>
<h2 id="standard-models-for-implementing-fga"><a class="header" href="#standard-models-for-implementing-fga">Standard Models for Implementing FGA</a></h2>
<p>There are several standard models for implementing FGA:</p>
<ul>
<li>
<p><code>Attribute-Based Access Control (ABAC)</code>: In <a href="https://en.wikipedia.org/wiki/Attribute-based_access_control">ABAC</a>, access control decisions are made by evaluating attributes such as user roles, resource attributes (e.g., type, size, status), requested action, current date and time, and any other relevant contextual information. ABAC allows for very granular control over access based on a wide range of attributes.</p>
</li>
<li>
<p><code>Policy-Based Access Control (PBAC)</code>: <a href="https://www.nextlabs.com/what-is-policy-based-access-control/">PBAC</a> is similar to ABAC but focuses more on defining policies than directly evaluating attributes. Policies in PBAC typically consist of rules or logic that dictate access control decisions based on various contextual factors. While ABAC relies heavily on data (attributes), PBAC emphasizes using logic to determine access.</p>
</li>
<li>
<p>Relationship-Based Access Control (ReBAC): <a href="https://en.wikipedia.org/wiki/Relationship-based_access_control">ReBAC</a> emphasizes the relationships between users and resources, as well as relationships between different resources. By considering these relationships, ReBAC provides a powerful and expressive model for describing complex authorization contexts. This can involve the attributes of users and resources and their interactions and dependencies.</p>
</li>
</ul>
<p>Each of these models offers different strengths and may be more suitable for different scenarios. FGA allows for fine grained control over access, enabling organizations to enforce highly specific access policies tailored to their requirements.</p>
<h2 id="streamlining-fga-by-implementing-rule-based-access-control"><a class="header" href="#streamlining-fga-by-implementing-rule-based-access-control">Streamlining FGA by Implementing Rule-Based Access Control:</a></h2>
<p>ABAC (Attribute-Based Access Control) focuses on data attributes, PBAC (Policy-Based Access Control) centers on logic, and ReBAC (Relationship-Based Access Control) emphasizes relationships between users and resources. But what if we combined all three to leverage the strengths of each? This is the idea behind <strong>Rule-Based Access Control (RuBAC)</strong>.</p>
<p>By embedding a lightweight rule engine, we can integrate multiple rules and actions to achieve the following:</p>
<ul>
<li>
<p><strong>Optimize ABAC</strong>: Reduce the number of required attributes since not all rules depend on them. For example, a standard rule like <em>"Customer data can only be accessed during working hours"</em> can be shared across policies.</p>
</li>
<li>
<p><strong>Flexible Policy Enforcement</strong>: Using a rule engine makes access policies more dynamic and simpler to manage.</p>
</li>
<li>
<p><strong>Infer Relationships</strong>: Automatically deduce relationships between entities. For instance, the rule engine could grant a user access to a file if they already have permission for the containing folder.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schema-registry"><a class="header" href="#json-schema-registry">JSON Schema Registry</a></h1>
<p>JSON Schema is a declarative language that provides a standardized way to describe and validate JSON data.</p>
<h3 id="what-it-does"><a class="header" href="#what-it-does">What it does</a></h3>
<p>JSON Schema defines the structure, content, data types, and constraints of JSON documents. It's an IETF standard that helps ensure the consistency and integrity of JSON data across applications.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p>JSON Schema uses keywords to define data properties. A JSON Schema validator checks if JSON documents conform to the schema.</p>
<h3 id="what-its-useful-for"><a class="header" href="#what-its-useful-for">What it's useful for</a></h3>
<ul>
<li>Describing existing data formats</li>
<li>Validating data as part of automated testing</li>
<li>Submitting client data</li>
<li>Defining how a record should be organized</li>
</ul>
<h3 id="what-is-a-json-schema-registry"><a class="header" href="#what-is-a-json-schema-registry">What is a JSON Schema Registry</a></h3>
<p>The JSON Schema Registry provides a centralized service for your JSON schemas with RESTful endpoints for storing and retrieving JSON schemas.</p>
<p>When using data in a distributed application with many RESTful APIs, it is important to ensure that it is well-formed and structured. If data is sent without prior validation, errors may occur on the services. A schema registry provides a way to ensure that the data is validated before it is sent and validated after it is received.</p>
<p>A schema registry is a service used to define and confirm the structure of data that is sent between consumers and providers. In a schema registry, developers can define what the data should look like and how it should be validated. The schemas can be utilized in the OpenAPI specifications to ensure that schemas can be externalized.</p>
<p>Schema records can also help ensure forward and backward compatibility when changes are made to the data structure. When a schema record is used, the data transfered with more schema information that can be used to ensure that applications reading the data can interpret it.</p>
<p>Given the API consumers and providers can belong to different groups or organizations, it is necessary to have a centralized service to manage the schemas so that they can be shared between them. This is why we have implemented this service as part of the light-portal.</p>
<h3 id="schema-specification-version"><a class="header" href="#schema-specification-version">Schema Specification Version</a></h3>
<p>The registry is heterogeneous registry as it can store schemas of different schema draft versions. By default the registry is configured to store schemas of Draft 2020-12. When a schema is added, the version which is currently is set, is what the schema is saved as.</p>
<p>The following list contains all supported specification versions.</p>
<ul>
<li>Draft 4</li>
<li>Draft 6</li>
<li>Draft 7</li>
<li>2019-09</li>
<li>2020-12</li>
</ul>
<h3 id="schema-version"><a class="header" href="#schema-version">Schema Version</a></h3>
<p>Once a schema is registed into the registry, it will be assigned as version 1. Each time it is updated, the version number will increase 1. When the schema is retrieve, the version number can be part of the URL to indicate that exact version will be retrieved. If version number is not in the URL, the latest version will be retrieved.</p>
<h3 id="access-endpoint"><a class="header" href="#access-endpoint">Access Endpoint</a></h3>
<h3 id="table-structure"><a class="header" href="#table-structure">Table Structure</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-controller"><a class="header" href="#light-controller">Light Controller</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaml-rule-registry"><a class="header" href="#yaml-rule-registry">YAML Rule Registry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
